[{"name":"TsInterop.Decode","comment":" The `TsInterop.Decode` module is what you use for\n\n  - Flags\n  - ToElm Ports\n\nBy building a Decoder with this API, you're also describing the source of truth for how to take a TypeScript type and\nturn it into an Elm type. Note that there is complete type information here just by using this API (no magic parsing or\nstatic analysis needed).\n\nLet's take this example:\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    int\n        |> map String.fromInt\n        |> runExample \"1000\"\n    --> { decoded = Ok \"1000\"\n    --> , tsType = \"number\"\n    --> }\n\nIn this example, there are no differences from how we would write this with the `elm/json` API. Let's consider the type\ninformation from two different sides: the Elm types (which would be used in an Elm type annotation), and the TypeScript\ntypes (which show up in the TypeScript Declaration file that `elm-ts-interop` generates to gives you nice autocompletion and type information).\n\n\n### The Elm type information\n\n  - The initial `Decoder`, `TsInterop.Decode.int`, has the Elm type `TsInterop.Decode.Decoder Int`. So Elm knows\n    this `Decoder` will either fail, or give us an `Int`.\n  - When we call `TsInterop.Decode.map String.fromInt`, the Elm type information changes. We're mapping with\n    `String.fromInt : String -> Int`. So that means we'll now decode into an Elm `String` instead of an `Int`. And that's\n    the final Elm type we'll end up with.\n\n\n### The TypeScript type information\n\n  - `TsInterop.Decode.int` expects a number from TypeScript.\n  - `TsInterop.Decode.map` applies a function to the decoded Elm value, but it doesn't change what we expect from TypeScript.\n    So we still expect a `number` from TypeScript. And we're done, so that's the final type we expect to receive from TypeScript.\n\n\n### Summary\n\nWe can apply more Decoders, like `TsInterop.Decode.list`, for example, to expect an array of that type from TypeScript,\nand a `List` of that Elm type. From there, it's just the same concept. **All the type information about the type that Elm will decode into, and the type that Elm expects from TypeScript, is built up as you build a Decoder**.\n\nThat means that the source of truth is the Decoder itself. Note that the Decoder doesn't specify just the Elm format, or just the TypeScript type as the source\nof truth. It specifies **how to turn a TypeScript type into an Elm type as the source of truth**. That means that\n\n  - You can change the decoder to change either type independently\n  - The two sides (Elm and TS) will always be in sync (as long as you are re-running the `elm-ts-interop` CLI at the appropriate time)\n\n\n## Decoders\n\n@docs Decoder\n\n@docs succeed, fail\n\n\n## Built-Ins\n\n@docs bool, float, int, string\n\n\n## Objects\n\n@docs field, at\n\n\n## Composite Types\n\n@docs list, array, nullable, oneOf, dict, keyValuePairs, oneOrMore, optionalField, optionalNullableField\n\n@docs index\n\n\n## Transformations\n\n@docs map\n\n\n## Combining\n\n@docs map2, andMap\n\n@docs map3, map4, map5, map6, map7, map8\n\n\n## TypeScript Literals\n\n@docs literal, null\n\n\n## Continuation\n\n@docs andThen, AndThenContinuation, andThenInit, andThenDecoder\n\n\n## elm/json Decoder Escape Hatches\n\nIf you have an existing decoder, you can use it with an [`unknown` type](https://mariusschulz.com/blog/the-unknown-type-in-typescript) in TypeScript.\n\nYou can also decode an arbitrary JSON value as with `elm/json`, and then use `elm/json` to process it further.\n\n@docs value, unknownAndThen, maybe\n\n\n## Using Decoders\n\nUsually you don't need to use these functions directly, but instead the code generated by the `elm-ts-interop` command line\ntool will use these for you under the hood. These can be helpful for debugging, or for building new tools on top of this package.\n\n@docs decoder, tsTypeToString\n\n","unions":[{"name":"AndThenContinuation","comment":" This type allows you to combine all the possible Decoders you could run in an [`andThen`](#andThen) continuation.\n\nThis API allows you to define all possible Decoders you might use up front, so that all possible TypeScript types\nthe continuation could decode are known _after building up the decoder instead of after running the decoder._\n\n","args":["a"],"cases":[]},{"name":"Decoder","comment":" Just like a `Decoder` in `elm/json`, except these `Decoder`s track the TypeScript types that they can successfully handle.\n","args":["value"],"cases":[]}],"aliases":[],"values":[{"name":"andMap","comment":" This is useful for building up a decoder with multiple fields in a pipeline style.\nSee <https://github.com/elm-community/json-extra/blob/2.0.0/docs/andMap.md>.\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    type alias Country = { name : String, populationInMillions : Int }\n\n    succeed Country\n        |> andMap (field \"name\" string)\n        |> andMap (field \"population\" (int |> map (\\totalPopulation -> floor (toFloat totalPopulation / 1000000.0))))\n        |> runExample \"\"\" {\"name\": \"Norway\", \"population\":5328000} \"\"\"\n    --> { decoded = Ok { name = \"Norway\", populationInMillions = 5 }\n    --> , tsType = \"{ population : number; name : string }\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder a -> TsInterop.Decode.Decoder (a -> b) -> TsInterop.Decode.Decoder b"},{"name":"andThen","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    example : AndThenContinuation (Int -> Decoder String)\n    example =\n        andThenInit\n            (\\v1Decoder v2PlusDecoder version ->\n                case version of\n                    1 -> v1Decoder\n                    _ -> v2PlusDecoder\n            )\n            |> andThenDecoder (field \"payload\" string)\n            |> andThenDecoder (at [ \"data\", \"payload\" ] string)\n\n\n    field \"version\" int |> andThen example\n        |> runExample \"\"\"{\"version\": 1, \"payload\": \"Hello\"}\"\"\"\n    --> { decoded = Ok \"Hello\"\n    --> , tsType = \"({ version : number } & { data : { payload : string } } | { payload : string })\"\n    --> }\n\n","type":"TsInterop.Decode.AndThenContinuation (value -> TsInterop.Decode.Decoder decodesTo) -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder decodesTo"},{"name":"andThenDecoder","comment":" ","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.AndThenContinuation (TsInterop.Decode.Decoder value -> final) -> TsInterop.Decode.AndThenContinuation final"},{"name":"andThenInit","comment":" ","type":"a -> TsInterop.Decode.AndThenContinuation a"},{"name":"array","comment":" Exactly the same as the [`list`](#list) `Decoder` except that it wraps the decoded `List` into an Elm `Array`.\n","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (Array.Array value)"},{"name":"at","comment":"\n\n    import Json.Decode\n    import Json.Encode\n\n    runExample : Decoder value -> String -> { decoded : Result String value, tsType : String }\n    runExample interopDecoder inputJson = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    type Mode = DarkMode | LightMode\n\n    modeDecoder : Decoder Mode\n    modeDecoder =\n        oneOf [ literal DarkMode <| Json.Encode.string \"dark\", literal LightMode <| Json.Encode.string \"light\" ]\n\n    \"\"\"{\"options\":\n           { \"mode\": \"dark\" },\n        \"version\": \"1.2.3\"}\"\"\"\n        |> runExample (at [ \"options\", \"mode\" ] modeDecoder)\n    --> { decoded = Ok DarkMode\n    --> , tsType = \"\"\"{ options : { mode : \"dark\" | \"light\" } }\"\"\"\n    --> }\n\n","type":"List.List String.String -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder value"},{"name":"bool","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    bool\n        |> runExample \"true\"\n    --> { decoded = Ok True\n    --> , tsType = \"boolean\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder Basics.Bool"},{"name":"decoder","comment":" Get a regular JSON Decoder that you can run using the `elm/json` API.\n","type":"TsInterop.Decode.Decoder value -> Json.Decode.Decoder value"},{"name":"dict","comment":"\n\n    import Json.Decode\n    import Json.Encode\n    import Dict exposing (Dict)\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    dict int\n        |> runExample \"\"\"{\"alice\":42,\"bob\":99}\"\"\"\n    --> { decoded = Ok (Dict.fromList [ ( \"alice\", 42 ), ( \"bob\", 99 ) ])\n    --> , tsType = \"{ [key: string]: number }\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (Dict.Dict String.String value)"},{"name":"fail","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    fail \"Failure message\"\n        |> runExample \"123.45\"\n    --> { decoded = Err \"Problem with the given value:\\n\\n123.45\\n\\nFailure message\"\n    --> , tsType = \"JsonValue\"\n    --> }\n\n","type":"String.String -> TsInterop.Decode.Decoder value"},{"name":"field","comment":"\n\n    import Json.Decode\n\n    runExample : Decoder value -> String -> { decoded : Result String value, tsType : String }\n    runExample interopDecoder inputJson = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    exampleDecoder : Decoder String\n    exampleDecoder =\n        field \"first\" string\n\n    \"\"\"{\"first\":\"James\",\"middle\":\"Tiberius\",\"last\":\"Kirk\"}\"\"\"\n        |> runExample exampleDecoder\n    --> { decoded = Ok \"James\"\n    --> , tsType = \"{ first : string }\"\n    --> }\n\n","type":"String.String -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder value"},{"name":"float","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    float\n        |> runExample \"1.23\"\n    --> { decoded = Ok 1.23\n    --> , tsType = \"number\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder Basics.Float"},{"name":"index","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    index 1 int\n        |> runExample \"[0,100,200]\"\n    --> { decoded = Ok 100\n    --> , tsType = \"[JsonValue,number,...JsonValue[]]\"\n    --> }\n\n    map2 Tuple.pair\n        ( index 1 int )\n        ( index 3 string )\n        |> runExample \"\"\"[0,100,\"a\",\"b\"]\"\"\"\n    --> { decoded = Ok ( 100, \"b\" )\n    --> , tsType = \"[JsonValue,number,JsonValue,string,...JsonValue[]]\"\n    --> }\n\n","type":"Basics.Int -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder value"},{"name":"int","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    int\n        |> runExample \"1000\"\n    --> { decoded = Ok 1000\n    --> , tsType = \"number\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder Basics.Int"},{"name":"keyValuePairs","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    keyValuePairs int\n        |> runExample \"\"\"{ \"alice\": 42, \"bob\": 99 }\"\"\"\n    --> { decoded = Ok [ ( \"alice\", 42 ), ( \"bob\", 99 ) ]\n    --> , tsType = \"{ [key: string]: number }\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (List.List ( String.String, value ))"},{"name":"list","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    list int\n        |> runExample \"[1,2,3]\"\n    --> { decoded = Ok [ 1, 2, 3 ]\n    --> , tsType = \"number[]\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (List.List value)"},{"name":"literal","comment":" TypeScript has support for literals.\n\n    import Json.Decode\n    import Json.Encode as JE\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    literal () (JE.string \"unit\")\n        |> runExample \"\"\" \"unit\" \"\"\"\n    --> { decoded = Ok ()\n    --> , tsType = \"\\\"unit\\\"\"\n    --> }\n\n","type":"value -> Json.Encode.Value -> TsInterop.Decode.Decoder value"},{"name":"map","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    int\n        |> map String.fromInt\n        |> runExample \"1000\"\n    --> { decoded = Ok \"1000\"\n    --> , tsType = \"number\"\n    --> }\n\n","type":"(value -> mapped) -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder mapped"},{"name":"map2","comment":" You can use [`map2`](#map2), [`map3`](#map3), etc. to build up decoders that have somewhat clearer error messages if something goes wrong.\nSome people prefer the pipeline style using [`andMap`](#andMap) as it has fewer parentheses and you don't have to change the number when\nyou add a new field. It's a matter of personal preference.\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    type alias Country = { name : String, populationInMillions : Int }\n\n    map2 Country\n        (field \"name\" string)\n        (field \"population\" (int |> map (\\totalPopulation -> floor (toFloat totalPopulation / 1000000.0))))\n        |> runExample \"\"\" {\"name\": \"Norway\", \"population\":5328000} \"\"\"\n    --> { decoded = Ok { name = \"Norway\", populationInMillions = 5 }\n    --> , tsType = \"{ name : string; population : number }\"\n    --> }\n\n","type":"(value1 -> value2 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder mapped"},{"name":"map3","comment":" ","type":"(value1 -> value2 -> value3 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder value3 -> TsInterop.Decode.Decoder mapped"},{"name":"map4","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder value3 -> TsInterop.Decode.Decoder value4 -> TsInterop.Decode.Decoder mapped"},{"name":"map5","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder value3 -> TsInterop.Decode.Decoder value4 -> TsInterop.Decode.Decoder value5 -> TsInterop.Decode.Decoder mapped"},{"name":"map6","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder value3 -> TsInterop.Decode.Decoder value4 -> TsInterop.Decode.Decoder value5 -> TsInterop.Decode.Decoder value6 -> TsInterop.Decode.Decoder mapped"},{"name":"map7","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder value3 -> TsInterop.Decode.Decoder value4 -> TsInterop.Decode.Decoder value5 -> TsInterop.Decode.Decoder value6 -> TsInterop.Decode.Decoder value7 -> TsInterop.Decode.Decoder mapped"},{"name":"map8","comment":" ","type":"(value1 -> value2 -> value3 -> value4 -> value5 -> value6 -> value7 -> value8 -> mapped) -> TsInterop.Decode.Decoder value1 -> TsInterop.Decode.Decoder value2 -> TsInterop.Decode.Decoder value3 -> TsInterop.Decode.Decoder value4 -> TsInterop.Decode.Decoder value5 -> TsInterop.Decode.Decoder value6 -> TsInterop.Decode.Decoder value7 -> TsInterop.Decode.Decoder value8 -> TsInterop.Decode.Decoder mapped"},{"name":"maybe","comment":" This function is somewhat risky in that it could cover up a failing Decoder by turning it into a `Nothing`. In\nsome cases, this may be what you're looking for, but if you're trying to deal with optional fields, it's safer to use\n[`optionalField`](#optionalField) and it will give you better type information. See the `thisShouldBeABoolean` example below. In that example,\nwe're decoding a JSON value which should have been a `boolean` but instead is a `string`. We'd like the `Decoder` to fail\nto let us know it wasn't able to process the value correctly, but instead it covers up the failure and decodes to `Nothing`.\n\nSo use this `Decoder` with care!\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    json : String\n    json = \"\"\"{ \"name\": \"tom\", \"age\": 42, \"thisShouldBeABoolean\": \"true\" }\"\"\"\n\n\n    -- WARNING: uh oh, this may not be the desired behavior!\n    maybe (field \"thisShouldBeABoolean\" bool) |> runExample json\n    --> { decoded = Ok Nothing\n    --> , tsType = \"{ thisShouldBeABoolean : boolean } | JsonValue\"\n    --> }\n\n    maybe (field \"height\" float) |> runExample json\n    --> { decoded = Ok Nothing\n    --> , tsType = \"{ height : number } | JsonValue\"\n    --> }\n\n    field \"height\" (maybe float) |> runExample json\n    --> { decoded = Err \"Problem with the given value:\\n\\n{\\n        \\\"name\\\": \\\"tom\\\",\\n        \\\"age\\\": 42,\\n        \\\"thisShouldBeABoolean\\\": \\\"true\\\"\\n    }\\n\\nExpecting an OBJECT with a field named `height`\"\n    --> , tsType = \"{ height : number | JsonValue }\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (Maybe.Maybe value)"},{"name":"null","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    null False |> runExample \"null\"\n    --> { decoded = Ok False\n    --> , tsType = \"null\"\n    --> }\n\n","type":"value -> TsInterop.Decode.Decoder value"},{"name":"nullable","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    nullable int |> runExample \"13\"\n    --> { decoded = Ok (Just 13)\n    --> , tsType = \"number | null\"\n    --> }\n\n    nullable int |> runExample \"null\"\n    --> { decoded = Ok Nothing\n    --> , tsType = \"number | null\"\n    --> }\n\n    nullable int |> runExample \"true\"\n    --> { decoded = Err \"Json.Decode.oneOf failed in the following 2 ways:\\n\\n\\n\\n(1) Problem with the given value:\\n    \\n    true\\n    \\n    Expecting null\\n\\n\\n\\n(2) Problem with the given value:\\n    \\n    true\\n    \\n    Expecting an INT\"\n    --> , tsType = \"number | null\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (Maybe.Maybe value)"},{"name":"oneOf","comment":" You can express quite a bit with `oneOf`! The resulting TypeScript types will be a Union of all the TypeScript types\nfor each [`Decoder`](#Decoder) in the List.\n\n    import Json.Decode\n    import Json.Encode\n\n    runExample : Decoder value -> String -> { decoded : Result String value, tsType : String }\n    runExample interopDecoder inputJson = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n\n    \"[1, 2, 3.14159, 4]\"\n        |> runExample ( list ( oneOf [ int |> map toFloat, float ] ) )\n    --> { decoded = Ok [1.0, 2.0, 3.14159, 4.0]\n    --> , tsType = \"\"\"(number | number)[]\"\"\"\n    --> }\n\n","type":"List.List (TsInterop.Decode.Decoder value) -> TsInterop.Decode.Decoder value"},{"name":"oneOrMore","comment":"\n\n    import Json.Decode\n    import Json.Encode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    oneOrMore (::) int\n        |> runExample \"[12345]\"\n    --> { decoded = Ok [ 12345 ]\n    --> , tsType = \"\"\"[ number, ...(number)[] ]\"\"\"\n    --> }\n\n    type TestResult\n        = Pass\n        | Fail String\n\n    testCaseDecoder : Decoder TestResult\n    testCaseDecoder =\n        oneOf [\n            field \"tag\" (literal Pass (Json.Encode.string \"pass\"))\n          , map2 (\\() message -> Fail message)\n              ( field \"tag\" (literal () (Json.Encode.string \"fail\")) )\n              ( field \"message\" string )\n        ]\n\n    oneOrMore (::) testCaseDecoder\n        |> runExample \"\"\"[ { \"tag\": \"pass\" } ]\"\"\"\n    --> { decoded = Ok [ Pass ]\n    --> , tsType = \"\"\"[ { tag : \"pass\" } | { tag : \"fail\"; message : string }, ...({ tag : \"pass\" } | { tag : \"fail\"; message : string })[] ]\"\"\"\n    --> }\n\n","type":"(a -> List.List a -> value) -> TsInterop.Decode.Decoder a -> TsInterop.Decode.Decoder value"},{"name":"optionalField","comment":" This is a safer (and more explicit) way to deal with optional fields compared to [`maybe`](#maybe). It may seem that wrapping\na [`field`](#field) `Decoder` in a [`maybe`](#maybe) `Decoder` achieves the same behavior, but the key difference is that the `maybe` version\nwill convert a failing decoder on a value that is present into `Nothing`, as if it wasn't present. Often what you want\nis for the malformed version to fail, which is exactly what this function will do.\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    json : String\n    json = \"\"\"{ \"name\": \"tom\", \"age\": null }\"\"\"\n\n    optionalField \"height\" float |> runExample json\n    --> { decoded = Ok Nothing\n    --> , tsType = \"{ height? : number }\"\n    --> }\n\n    optionalField \"age\" int |> runExample json\n    --> { decoded = Err \"Problem with the value at json.age:\\n\\n    null\\n\\nExpecting an INT\"\n    --> , tsType = \"{ age? : number }\"\n    --> }\n\n","type":"String.String -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (Maybe.Maybe value)"},{"name":"optionalNullableField","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    json : String\n    json = \"\"\"{ \"name\": \"tom\", \"age\": null }\"\"\"\n\n    optionalNullableField \"height\" float |> runExample json\n    --> { decoded = Ok Nothing\n    --> , tsType = \"{ height? : number | null }\"\n    --> }\n\n    optionalNullableField \"age\" int |> runExample json\n    --> { decoded = Ok Nothing\n    --> , tsType = \"{ age? : number | null }\"\n    --> }\n\n","type":"String.String -> TsInterop.Decode.Decoder value -> TsInterop.Decode.Decoder (Maybe.Maybe value)"},{"name":"string","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    string\n        |> runExample \"\"\" \"Hello!\" \"\"\"\n    --> { decoded = Ok \"Hello!\"\n    --> , tsType = \"string\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder String.String"},{"name":"succeed","comment":"\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    succeed \"abcdefg\"\n        |> runExample \"12345\"\n    --> { decoded = Ok \"abcdefg\"\n    --> , tsType = \"JsonValue\"\n    --> }\n\n","type":"value -> TsInterop.Decode.Decoder value"},{"name":"tsTypeToString","comment":" ","type":"TsInterop.Decode.Decoder value -> String.String"},{"name":"unknownAndThen","comment":" If you need to run a regular JSON Decoder in an `andThen`, you can use this function, but it will yield a Decoder\nwith an unknown TypeScript type.\n\n    import Json.Decode as JD\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = JD.decodeString (decoder interopDecoder) inputJson |> Result.mapError JD.errorToString }\n\n    field \"version\" int |> unknownAndThen (\\versionNumber ->\n        if versionNumber == 1 then\n          JD.field \"payload\" JD.string\n        else\n          JD.at [ \"data\", \"payload\" ] JD.string\n    )\n        |> runExample \"\"\"{\"version\": 1, \"payload\": \"Hello\"}\"\"\"\n    --> { decoded = Ok \"Hello\"\n    --> , tsType = \"JsonValue\"\n    --> }\n\n","type":"(a -> Json.Decode.Decoder b) -> TsInterop.Decode.Decoder a -> TsInterop.Decode.Decoder b"},{"name":"value","comment":" Gives you an escape hatch to decode to a plain `elm/json` `Json.Decode.Value`. This has the TypeScript type `unknown`.\nAvoid using this when possible.\n\n    import Json.Decode\n\n\n    runExample : String -> Decoder value -> { decoded : Result String value, tsType : String }\n    runExample inputJson interopDecoder = { tsType = tsTypeToString interopDecoder , decoded = Json.Decode.decodeString (decoder interopDecoder) inputJson |> Result.mapError Json.Decode.errorToString }\n\n    value\n        |> runExample \"Hello\"\n    --> { decoded = (Json.Decode.decodeString Json.Decode.value \"Hello\" |> Result.mapError Json.Decode.errorToString)\n    --> , tsType = \"JsonValue\"\n    --> }\n\n","type":"TsInterop.Decode.Decoder Json.Decode.Value"}],"binops":[]},{"name":"TsInterop.Encode","comment":" The `TsInterop.Encode` module is what you use for\n\n  - FromElm Ports\n\nSee [TsInterop.Decode](TsInterop.Decode) for the API used for Flags and ToElm Ports.\n\nBy building an `Encoder` with this API, you're also describing the source of truth for taking an Elm type and\nturning it into a JSON value with a TypeScript type. Note that there is no magic involved in this process.\nThe `elm-ts-interop` CLI simply gets the [`typeDef`](#typeDef) from your `Encoder` to generate the\nTypeScript Declaration file for your compiled Elm code.\n\n@docs Encoder\n\n\n## Built-Ins\n\n@docs string, int, float, literal, bool, null\n\n\n## Transforming\n\n@docs map\n\n\n## Objects\n\n@docs object, Property, optional, required\n\n\n## Union Types\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input =\n        { tsType = typeDef encoder_, output = input |> encoder encoder_ |> Encode.encode 0 }\n\n    type ToJs\n        = SendPresenceHeartbeat\n        | Alert String\n\n    unionEncoder : Encoder ToJs\n    unionEncoder =\n        union\n            (\\vSendHeartbeat vAlert value ->\n                case value of\n                    SendPresenceHeartbeat ->\n                        vSendHeartbeat\n                    Alert string ->\n                        vAlert string\n            )\n            |> variant0 \"SendPresenceHeartbeat\"\n            |> variantObject \"Alert\" [ required \"message\" identity string ]\n            |> buildUnion\n\n\n    Alert \"Hello TypeScript!\"\n            |> runExample unionEncoder\n    --> { output = \"\"\"{\"tag\":\"Alert\",\"message\":\"Hello TypeScript!\"}\"\"\"\n    --> , tsType = \"\"\"{ tag : \"Alert\"; message : string } | { tag : \"SendPresenceHeartbeat\" }\"\"\"\n    --> }\n\n@docs UnionBuilder, union, variant, variant0, variantObject, variantLiteral, buildUnion\n\n@docs UnionEncodeValue\n\n\n## Collections\n\n@docs list, dict, tuple, triple, maybe\n\n\n## In-Depth Example\n\nYou can use `elm-ts-interop` to build up `Encoder`s that have the same TypeScript type as a web platform API expects.\nHere's an example that we could use to call the [`scrollIntoView`](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView)\nmethod on a DOM Element.\n\n    import Json.Encode\n\n    type Behavior\n        = Auto\n        | Smooth\n\n    type Alignment\n        = Start\n        | Center\n        | End\n        | Nearest\n\n    scrollIntoViewEncoder : Encoder\n            { behavior : Maybe Behavior\n            , block : Maybe Alignment\n            , inline : Maybe Alignment\n            }\n    scrollIntoViewEncoder =\n        object\n            [ optional \"behavior\" .behavior behaviorEncoder\n            , optional \"block\" .block alignmentEncoder\n            , optional \"inline\" .inline alignmentEncoder\n            ]\n\n    behaviorEncoder : Encoder Behavior\n    behaviorEncoder =\n        union\n            (\\vAuto vSmooth value ->\n                case value of\n                    Auto ->\n                        vAuto\n                    Smooth ->\n                        vSmooth\n            )\n            |> variantLiteral (Json.Encode.string \"auto\")\n            |> variantLiteral (Json.Encode.string \"smooth\")\n            |> buildUnion\n\n\n    alignmentEncoder : Encoder Alignment\n    alignmentEncoder =\n        union\n            (\\vStart vCenter vEnd vNearest value ->\n                case value of\n                    Start ->\n                        vStart\n                    Center ->\n                        vCenter\n                    End ->\n                        vEnd\n                    Nearest ->\n                        vNearest\n            )\n            |> variantLiteral (Json.Encode.string \"start\")\n            |> variantLiteral (Json.Encode.string \"center\")\n            |> variantLiteral (Json.Encode.string \"end\")\n            |> variantLiteral (Json.Encode.string \"nearest\")\n            |> buildUnion\n\n\n    { behavior = Just Auto, block = Just Nearest, inline = Nothing }\n            |> runExample scrollIntoViewEncoder\n    --> { output = \"\"\"{\"behavior\":\"auto\",\"block\":\"nearest\"}\"\"\"\n    --> , tsType = \"\"\"{ behavior? : \"smooth\" | \"auto\"; block? : \"nearest\" | \"end\" | \"center\" | \"start\"; inline? : \"nearest\" | \"end\" | \"center\" | \"start\" }\"\"\"\n    --> }\n\n\n## Escape Hatch\n\n@docs value\n\n\n## Executing Encoders\n\nUsually you don't need to use these functions directly, but instead the code generated by the `elm-ts-interop` command line\ntool will use these for you under the hood. These can be helpful for debugging, or for building new tools on top of this package.\n\n@docs typeDef, encoder\n\n","unions":[{"name":"Encoder","comment":" Similar to a `Json.Encode.Value` in `elm/json`. However, a `TsInterop.Encode.Encoder` in `elm-ts-interop` has this key difference from an `elm/json` `Encode.Value`:\n\n  - `elm/json` `Json.Encode.Value` - a value representing an encoded JSON value\n  - `elm-ts-interop` `TsInterop.Encode.Encoder` - a _function_ for turning an Elm value into an encoded JSON value. The `Encoder` itself has a definite TypeScript type, before you even pass in an Elm value to turn into JSON.\n\nSo the `elm-ts-interop` `Encoder` expects a specific type of Elm value, and knows how to turn that Elm value into JSON.\n\nLet's compare the two with an example for encoding a first and last name.\n\n    import Json.Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input =\n        { tsType = typeDef encoder_, output = input |> encoder encoder_ |> Json.Encode.encode 0 }\n\n    elmJsonNameEncoder : { first : String, last : String }\n        -> Json.Encode.Value\n    elmJsonNameEncoder { first, last } =\n        Json.Encode.object\n            [ ( \"first\", Json.Encode.string first )\n            , ( \"last\", Json.Encode.string last )\n            ]\n\n    { first = \"James\", last = \"Kirk\" }\n            |> elmJsonNameEncoder\n            |> Json.Encode.encode 0\n    --> \"\"\"{\"first\":\"James\",\"last\":\"Kirk\"}\"\"\"\n\n    nameEncoder : Encoder { first : String, last : String }\n    nameEncoder =\n        object\n            [ required \"first\" .first string\n            , required \"last\" .last string\n            ]\n\n    { first = \"James\", last = \"Kirk\" }\n            |> runExample nameEncoder\n    --> { output = \"\"\"{\"first\":\"James\",\"last\":\"Kirk\"}\"\"\"\n    --> , tsType = \"{ first : string; last : string }\"\n    --> }\n\n","args":["input"],"cases":[]},{"name":"Property","comment":" ","args":["input"],"cases":[]},{"name":"UnionBuilder","comment":" ","args":["match"],"cases":[]},{"name":"UnionEncodeValue","comment":" We can guarantee that you're only encoding to a given\nset of possible shapes in a union type by ensuring that\nall the encoded values come from the union pipeline,\nusing functions like `variantLiteral`, `variantObject`, etc.\n\nApplying another variant function in your union pipeline will\ngive you more functions/values to give UnionEncodeValue's with\ndifferent shapes, if you need them.\n\n","args":[],"cases":[]}],"aliases":[],"values":[{"name":"bool","comment":"\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    True\n        |> runExample bool\n    --> { output = \"true\"\n    --> , tsType = \"boolean\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder Basics.Bool"},{"name":"buildUnion","comment":" ","type":"TsInterop.Encode.UnionBuilder (match -> TsInterop.Encode.UnionEncodeValue) -> TsInterop.Encode.Encoder match"},{"name":"dict","comment":"\n\n    import Json.Encode as Encode\n    import Dict\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    Dict.fromList [ ( \"a\", \"123\" ), ( \"b\", \"456\" ) ]\n        |> runExample ( dict identity string )\n    --> { output = \"\"\"{\"a\":\"123\",\"b\":\"456\"}\"\"\"\n    --> , tsType = \"{ [key: string]: string }\"\n    --> }\n\n","type":"(comparableKey -> String.String) -> TsInterop.Encode.Encoder input -> TsInterop.Encode.Encoder (Dict.Dict comparableKey input)"},{"name":"encoder","comment":" ","type":"TsInterop.Encode.Encoder input -> input -> Json.Encode.Value"},{"name":"float","comment":"\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    123.45\n        |> runExample float\n    --> { output = \"123.45\"\n    --> , tsType = \"number\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder Basics.Float"},{"name":"int","comment":"\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    123\n        |> runExample int\n    --> { output = \"123\"\n    --> , tsType = \"number\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder Basics.Int"},{"name":"list","comment":"\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    [ \"Hello\", \"World!\" ]\n        |> runExample ( list string )\n    --> { output = \"\"\"[\"Hello\",\"World!\"]\"\"\"\n    --> , tsType = \"string[]\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder a -> TsInterop.Encode.Encoder (List.List a)"},{"name":"literal","comment":" TypeScript has the concept of a [Literal Type](https://www.typescriptlang.org/docs/handbook/literal-types.html).\nA Literal Type is just a JSON value. But unlike other types, it is constrained to a specific literal.\n\nFor example, `200` is a Literal Value (not just any `number`). Elm doesn't have the concept of Literal Values that the\ncompiler checks. But you can map Elm Custom Types nicely into TypeScript Literal Types. For example, you could represent\nHTTP Status Codes in TypeScript with a Union of Literal Types like this:\n\n```typescript\ntype HttpStatus = 200 | 404 // you can include more status codes\n```\n\nThe type `HttpStatus` is limited to that set of numbers. In Elm, you might represent that discrete set of values with\na Custom Type, like so:\n\n    type HttpStatus\n        = Success\n        | NotFound\n\nHowever you name them, you can map those Elm types into equivalent TypeScript values using a union of literals like so:\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n    httpStatusEncoder : Encoder HttpStatus\n    httpStatusEncoder =\n        union\n            (\\vSuccess vNotFound value ->\n                case value of\n                    Success ->\n                        vSuccess\n                    NotFound ->\n                        vNotFound\n            )\n            |> variantLiteral (Encode.int 200)\n            |> variantLiteral (Encode.int 404)\n            |> buildUnion\n\n    NotFound\n        |> runExample httpStatusEncoder\n    --> { output = \"404\"\n    --> , tsType = \"404 | 200\"\n    --> }\n\n","type":"Json.Encode.Value -> TsInterop.Encode.Encoder a"},{"name":"map","comment":" An [`Encoder`](#Encoder) represents turning an Elm input value into a JSON value that has a TypeScript type information.\n\nThis `map` function allows you to transform the **Elm input value**, not the resulting JSON output. So this will feel\ndifferent than using [`TsInterop.Decode.map`](TsInterop.Decode#map), or other familiar `map` functions\nthat transform an **Elm output value**, such as `Maybe.map` and `Json.Decode.map`.\n\nThink of `TsInterop.Encode.map` as changing **how to get the value that you want to turn into JSON**. For example,\nif we're passing in some nested data and need to get a field\n\n    import Json.Encode as Encode\n\n    runExample : input -> Encoder input -> { output : String, tsType : String }\n    runExample input encoder_ = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n    picardData : { data : { first : String, last : String, rank : String } }\n    picardData = { data = { first = \"Jean Luc\", last = \"Picard\", rank = \"Captain\" } }\n\n\n    string\n        |> map .rank\n        |> map .data\n        |> runExample picardData\n    --> { output = \"\\\"Captain\\\"\"\n    --> , tsType = \"string\"\n    --> }\n\nLet's consider how the types change as we `map` the `Encoder`.\n\n    encoder1 : Encoder String\n    encoder1 =\n        string\n\n    encoder2 : Encoder { rank : String }\n    encoder2 =\n        string\n            |> map .rank\n\n    encoder3 : Encoder { data : { rank : String } }\n    encoder3 =\n        string\n            |> map .rank\n            |> map .data\n\n    (encoder1, encoder2, encoder3) |> always ()\n    --> ()\n\nSo `map` is applying a function that tells the Encoder how to get the data it needs.\n\nIf we want to send a string through a port, then we start with a [`string`](#string) `Encoder`. Then we `map` it to\nturn our input data into a String (because `string` is `Encoder String`).\n\n    string\n        |> map (\\outerRecord -> outerRecord.data.first ++ \" \" ++ outerRecord.data.last)\n        |> runExample picardData\n    --> { output = \"\\\"Jean Luc Picard\\\"\"\n    --> , tsType = \"string\"\n    --> }\n\n","type":"(input -> mappedInput) -> TsInterop.Encode.Encoder mappedInput -> TsInterop.Encode.Encoder input"},{"name":"maybe","comment":"\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    Just 42\n        |> runExample ( maybe int )\n    --> { output = \"42\"\n    --> , tsType = \"number | null\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder a -> TsInterop.Encode.Encoder (Maybe.Maybe a)"},{"name":"null","comment":" Equivalent to `literal Encode.null`.\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    ()\n        |> runExample null\n    --> { output = \"null\"\n    --> , tsType = \"null\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder input"},{"name":"object","comment":"\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input =\n        { tsType = typeDef encoder_, output = input |> encoder encoder_ |> Encode.encode 0 }\n\n    nameEncoder : Encoder { first : String, last : String }\n    nameEncoder =\n        object\n            [ required \"first\" .first string\n            , required \"last\" .last string\n            ]\n\n\n    { first = \"James\", last = \"Kirk\" }\n            |> runExample nameEncoder\n    --> { output = \"\"\"{\"first\":\"James\",\"last\":\"Kirk\"}\"\"\"\n    --> , tsType = \"{ first : string; last : string }\"\n    --> }\n\n    fullNameEncoder : Encoder { first : String, middle : Maybe String, last : String }\n    fullNameEncoder =\n        object\n            [ required \"first\" .first string\n            , optional \"middle\" .middle string\n            , required \"last\" .last string\n            ]\n\n    { first = \"James\", middle = Just \"Tiberius\", last = \"Kirk\" }\n            |> runExample fullNameEncoder\n    --> { output = \"\"\"{\"first\":\"James\",\"middle\":\"Tiberius\",\"last\":\"Kirk\"}\"\"\"\n    --> , tsType = \"{ first : string; middle? : string; last : string }\"\n    --> }\n\n","type":"List.List (TsInterop.Encode.Property input) -> TsInterop.Encode.Encoder input"},{"name":"optional","comment":" ","type":"String.String -> (input -> Maybe.Maybe mappedInput) -> TsInterop.Encode.Encoder mappedInput -> TsInterop.Encode.Property input"},{"name":"required","comment":" ","type":"String.String -> (input -> mappedInput) -> TsInterop.Encode.Encoder mappedInput -> TsInterop.Encode.Property input"},{"name":"string","comment":" Encode a string.\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    \"Hello!\"\n        |> runExample string\n    --> { output = \"\\\"Hello!\\\"\"\n    --> , tsType = \"string\"\n    --> }\n\nYou can use `map` to apply an accessor function for how to get that String.\n\n    { data = { first = \"James\", last = \"Kirk\" } }\n        |> runExample ( string |> map .first |> map .data )\n    --> { output = \"\\\"James\\\"\"\n    --> , tsType = \"string\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder String.String"},{"name":"triple","comment":" Same as [`tuple`](#tuple), but with Triples\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    ( \"Jane Doe\", True, 123 )\n        |> runExample ( triple string bool int )\n    --> { output = \"\"\"[\"Jane Doe\",true,123]\"\"\"\n    --> , tsType = \"[ string, boolean, number ]\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder input1 -> TsInterop.Encode.Encoder input2 -> TsInterop.Encode.Encoder input3 -> TsInterop.Encode.Encoder ( input1, input2, input3 )"},{"name":"tuple","comment":" TypeScript [has a Tuple type](https://www.typescriptlang.org/docs/handbook/basic-types.html#tuple). It's just an\nArray with 2 items, and the TypeScript compiler will enforce that there are two elements. You can turn an Elm Tuple\ninto a TypeScript Tuple.\n\n    import Json.Encode as Encode\n\n    runExample : Encoder input -> input -> { output : String, tsType : String }\n    runExample encoder_ input = { tsType = typeDef encoder_ , output = input |> encoder encoder_ |> Encode.encode 0 }\n\n\n    ( \"John Doe\", True )\n        |> runExample ( tuple string bool )\n    --> { output = \"\"\"[\"John Doe\",true]\"\"\"\n    --> , tsType = \"[ string, boolean ]\"\n    --> }\n\nIf your target Elm value isn't a tuple, you can [`map`](#map) it into one\n\n    { name = \"John Smith\", isAdmin = False }\n        |> runExample\n            (tuple string bool\n                |> map\n                    (\\{ name, isAdmin } ->\n                        ( name, isAdmin )\n                    )\n            )\n    --> { output = \"\"\"[\"John Smith\",false]\"\"\"\n    --> , tsType = \"[ string, boolean ]\"\n    --> }\n\n","type":"TsInterop.Encode.Encoder input1 -> TsInterop.Encode.Encoder input2 -> TsInterop.Encode.Encoder ( input1, input2 )"},{"name":"typeDef","comment":" ","type":"TsInterop.Encode.Encoder input -> String.String"},{"name":"union","comment":" ","type":"constructor -> TsInterop.Encode.UnionBuilder constructor"},{"name":"value","comment":" This is an escape hatch that allows you to send arbitrary JSON data. The type will\nbe JSON in TypeScript, so you won't have any specific type information. In some cases,\nthis is fine, but in general you'll usually want to use other functions in this module\nto build up a well-typed [`Encoder`](#Encoder).\n","type":"TsInterop.Encode.Encoder Json.Encode.Value"},{"name":"variant","comment":" ","type":"TsInterop.Encode.Encoder input -> TsInterop.Encode.UnionBuilder ((input -> TsInterop.Encode.UnionEncodeValue) -> match) -> TsInterop.Encode.UnionBuilder match"},{"name":"variant0","comment":" ","type":"String.String -> TsInterop.Encode.UnionBuilder (TsInterop.Encode.UnionEncodeValue -> match) -> TsInterop.Encode.UnionBuilder match"},{"name":"variantLiteral","comment":" ","type":"Json.Encode.Value -> TsInterop.Encode.UnionBuilder (TsInterop.Encode.UnionEncodeValue -> match) -> TsInterop.Encode.UnionBuilder match"},{"name":"variantObject","comment":" ","type":"String.String -> List.List (TsInterop.Encode.Property arg1) -> TsInterop.Encode.UnionBuilder ((arg1 -> TsInterop.Encode.UnionEncodeValue) -> match) -> TsInterop.Encode.UnionBuilder match"}],"binops":[]}]